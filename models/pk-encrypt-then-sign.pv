(* Protocol:
      I -> R: sign(skI,pk_enc(pkR,Request(vkI, req)))
      R -> I: sign(skR,pk_enc(pkI,Response(vkR, f(resp))))
*)

(* Messages *)
fun Request(vkey,bitstring): bitstring [data].
fun Response(vkey,bitstring): bitstring [data].

(* Protocol Events *)
event SendReq(vkey,vkey,bitstring).
event RecvReq(vkey,vkey,bitstring).
event SendResp(vkey,vkey,bitstring,bitstring).
event RecvResp(vkey,vkey,bitstring,bitstring).
event Compromised(vkey).

(* The following processes show the re-signing attack on the protocol.
   To fix the protocol and prevent the attack, comment the lines
   marked with BUG and uncomment the lines marked with FIX *)

(* Process for Initiator Role *)
let I(skI:skey,dkI:dkey,
      vkR:vkey,ekR:ekey,
      req:bitstring) =
    let vkI = skey2vkey(skI) in
    event SendReq(vkI,vkR,req);
    let c = pk_enc(ekR,Request(vkI,req)) in
    out (ch,(c,sign(skI,c)));
    in (ch,(resp_msg:bitstring,resp_sig:bitstring));
    if verify(vkR,resp_msg,resp_sig) then (
       let Response(vkR',resp) = pk_dec(dkI,resp_msg) in
(*BUG*) (* if vkR = vkR' then *)
       event RecvResp(vkI,vkR,req,resp)).

(* Process for Responder Role *)
fun f(bitstring):bitstring [private].
let R(skR:skey,dkR:dkey,
      vkI:vkey,ekI:ekey) =
    let vkR = skey2vkey(skR) in
    in (ch,(req_msg:bitstring,req_sig:bitstring));
    if verify(vkI,req_msg,req_sig) then (
        let Request(vkI',m) = pk_dec(dkR,req_msg) in
(*BUG*) (* if vkI = vkI' then  *)
	(event RecvReq(vkI,vkR,m);
	 let resp = f(m) in
	 event SendResp(vkI,vkR,m,resp);
	 let c = pk_enc(ekI,Response(vkR,resp)) in
	 out (ch,(c,sign(skR,c))))).


(* Test Scenario *)

(* Private Keys for honest A, B, and a compromised principal O *)
free skA:skey [private].
free skB:skey [private].
free dkA:dkey [private].
free dkB:dkey [private].
free skO:skey.
free dkO:dkey.

(* Secret Requests send by A and B *)
free reqAB:bitstring [private].
free reqAB':bitstring [private].
free reqBA:bitstring [private].
free reqAO:bitstring.
free reqOB:bitstring.

(* Main process: any number of sessions between A and B *)

let main =
    !I(skA,dkA,skey2vkey(skB),dkey2ekey(dkB),reqAB) |
    !R(skB,dkB,skey2vkey(skA),dkey2ekey(dkA)) |
    !I(skB,dkB,skey2vkey(skA),dkey2ekey(dkA),reqBA) |
    !R(skA,dkA,skey2vkey(skB),dkey2ekey(dkB)) |
    !I(skA,dkA,skey2vkey(skO),dkey2ekey(dkO),reqAO) |
    !R(skB,dkB,skey2vkey(skO),dkey2ekey(dkO)) |
    out(ch,(skey2vkey(skA),dkey2ekey(dkA),skey2vkey(skB),dkey2ekey(dkB),skO,dkO)).

(* SECURITY GOALS *)

(* Secrecy Goals: reqAB, f(reqAB), reqBA, f(reqBA) should be secret *)
query attacker(reqAB).
query attacker(f(reqAB)).
query attacker(reqBA).
query attacker(f(reqBA)).

(* Authentication Goals, stated as correspondences between protocol events *)
query req:bitstring;
      event(RecvReq(skey2vkey(skA),skey2vkey(skB),req)) ==>
      event(SendReq(skey2vkey(skA),skey2vkey(skB),req)).
query req:bitstring,resp:bitstring;
      event(RecvResp(skey2vkey(skA),skey2vkey(skB),req,resp)) ==>
      event(SendResp(skey2vkey(skA),skey2vkey(skB),req,resp)).

process main






