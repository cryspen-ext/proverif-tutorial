(* Public untrusted network channel *)
free ch: channel.

(* Signature and verification keys *)
type skey.
type vkey.
fun vk(skey):vkey.

(* Encryption and decryption keys *)
type dkey.
type ekey.
fun ek(dkey):ekey.

(* Public-Key Encryption *)
fun penc(ekey,bitstring): bitstring.
reduc forall dk:dkey, m:bitstring;
      pdec(dk,penc(ek(dk),m)) = m.

(* Public-Key Signatures *)
fun sign(skey,bitstring): bitstring.
reduc forall sk:skey, m:bitstring;
      verify(vk(sk),m,sign(sk,m)) = true.

(* Protocol:
      I -> R: sign(skI,penc(pkR,req))
      R -> I: sign(skR,penc(pkI,f(resp)))
*)

(* Messages *)
fun request(bitstring): bitstring [data].
fun response(bitstring): bitstring [data].

(* Protocol Events *)
event SendReq(vkey,vkey,bitstring).
event RecvReq(vkey,vkey,bitstring).
event SendResp(vkey,vkey,bitstring,bitstring).
event RecvResp(vkey,vkey,bitstring,bitstring).
event Compromised(vkey).

(* The following processes show the reflection attack on PSK-RPC.
   To fix the protocol and prevent the attack, comment the lines
   marked with BUG and uncomment the lines marked with FIX *)

(* Process for Initiator Role *)
let I(skI:skey,dkI:dkey,
      vkR:vkey,ekR:ekey,
      req:bitstring) =
    let vkI = vk(skI) in
    event SendReq(vkI,vkR,req);
(*BUG*) (*   let req_sig = sign(skI,(request(req))) in *)
(*FIX*)    let req_sig = sign(skI,(vkR,request(req))) in
    out (ch,penc(ekR,(request(req),req_sig)));
    in (ch,resp_msg:bitstring);
    let (response(resp),resp_sig:bitstring) = pdec(dkI,resp_msg) in
(*BUG*) (*   if verify(vkR,(response(resp)),resp_sig) then *)
(*FIX*)    if verify(vkR,(vkI,request(req),response(resp)),resp_sig) then
    event RecvResp(vkI,vkR,req,resp).

(* Process for Responder Role *)
fun f(bitstring):bitstring [private].
let R(skR:skey,dkR:dkey,
      vkI:vkey,ekI:ekey) =
    let vkR = vk(skR) in
    in (ch,req_msg:bitstring);
    let (request(req),req_sig:bitstring) = pdec(dkR,req_msg) in
(*BUG*) (*   if verify(vkI,(request(req)),req_sig) then ( *)
(*FIX*)    if verify(vkI,(vkR,request(req)),req_sig) then (
         event RecvReq(vkI,vkR,req);
	 let resp = f(req) in
	 event SendResp(vkI,vkR,req,resp);
(*BUG*) (*   let resp_sig = sign(skR,(response(resp))) in *)
(*FIX*)	 let resp_sig = sign(skR,(vkI,request(req),response(resp))) in
	 out (ch,penc(ekI,(response(resp),resp_sig)))).


(* Test Scenario *)

(* Private Keys for honest A, B, and a compromised principal O *)
free skA:skey [private].
free skB:skey [private].
free dkA:dkey [private].
free dkB:dkey [private].
free skO:skey.
free dkO:dkey.

(* Secret Requests send by A and B *)
free reqAB:bitstring [private].
free reqAB':bitstring [private].
free reqBA:bitstring [private].
free reqAO:bitstring.
free reqOB:bitstring.

(* Main process: any number of sessions between A and B *)

let main =
    !I(skA,dkA,vk(skB),ek(dkB),reqAB) |
    !R(skB,dkB,vk(skA),ek(dkA)) |
    !I(skB,dkB,vk(skA),ek(dkA),reqBA) |
    !R(skA,dkA,vk(skB),ek(dkB)) |
    !I(skA,dkA,vk(skO),ek(dkO),reqAO) |
    !R(skB,dkB,vk(skO),ek(dkO)) |
    !I(skA,dkA,vk(skB),ek(dkB),reqAB') |
    out(ch,(vk(skA),ek(dkA),vk(skB),ek(dkB),skO,dkO)).

(* SECURITY GOALS *)

(* Secrecy Goals: reqAB, f(reqAB), reqBA, f(reqBA) should be secret *)
query attacker(reqAB).
query attacker(f(reqAB)).
query attacker(reqBA).
query attacker(f(reqBA)).

(* Authentication Goals, stated as correspondences between protocol events *)
query req:bitstring;
      event(RecvReq(vk(skA),vk(skB),req)) ==>
      event(SendReq(vk(skA),vk(skB),req)).
query req:bitstring,resp:bitstring;
      event(RecvResp(vk(skA),vk(skB),req,resp)) ==>
      event(SendResp(vk(skA),vk(skB),req,resp)).


query event(SendReq(vk(skA),vk(skB),reqAB)).
query event(SendReq(vk(skB),vk(skA),reqBA)).
query event(SendReq(vk(skA),vk(skO),reqAO)).
query event(RecvReq(vk(skA),vk(skB),reqAB)).
query event(RecvReq(vk(skB),vk(skA),reqBA)).
query event(RecvReq(vk(skO),vk(skB),reqOB)).
query event(SendResp(vk(skA),vk(skB),reqAB,f(reqAB))).
query event(SendResp(vk(skB),vk(skA),reqBA,f(reqBA))).
query event(SendResp(vk(skO),vk(skB),reqOB,f(reqOB))).
query event(RecvResp(vk(skA),vk(skB),reqAB,f(reqAB))).
query event(RecvResp(vk(skB),vk(skA),reqBA,f(reqBA))).
query event(RecvResp(vk(skA),vk(skO),reqAO,f(reqAO))).

process main






