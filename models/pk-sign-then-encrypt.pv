(* RPC Protocol (sign-then-encrypt):
      I -> R: pk_enc(ekR,(req,sign(skI,Request(req))))
      R -> I: pk_enc(ekI,(f(req),sign(skR,Response(f(req)))))
*)

(* Messages *)
fun Request(bitstring): bitstring [data].
fun Response(bitstring): bitstring [data].

(* Protocol Events *)
event SendReq(vkey,vkey,bitstring).
event RecvReq(vkey,vkey,bitstring).
event SendResp(vkey,vkey,bitstring,bitstring).
event RecvResp(vkey,vkey,bitstring,bitstring).
event Compromised(vkey).

(* The following processes show the reflection attack on PSK-RPC.
   To fix the protocol and prevent the attack, comment the lines
   marked with BUG and uncomment the lines marked with FIX *)

(* Process for Initiator Role *)
let I(skI:skey,dkI:dkey,
      vkR:vkey,ekR:ekey,
      req:bitstring) =
    let vkI = skey2vkey(skI) in
    event SendReq(vkI,vkR,req);
(*BUG*) (*   let req_sig = sign(skI,(Request(req))) in *)
(*FIX*)    let req_sig = sign(skI,(vkR,Request(req))) in
    out (ch,pk_enc(ekR,(Request(req),req_sig)));
    in (ch,resp_msg:bitstring);
    let (Response(resp),resp_sig:bitstring) = pk_dec(dkI,resp_msg) in
(*BUG*) (*   if verify(vkR,(Response(resp)),resp_sig) then *)
(*FIX*)    if verify(vkR,(vkI,Request(req),Response(resp)),resp_sig) then
    event RecvResp(vkI,vkR,req,resp).

(* Process for Responder Role *)
fun f(bitstring):bitstring [private].
let R(skR:skey,dkR:dkey,
      vkI:vkey,ekI:ekey) =
    let vkR = skey2vkey(skR) in
    in (ch,req_msg:bitstring);
    let (Request(req),req_sig:bitstring) = pk_dec(dkR,req_msg) in
(*BUG*) (*   if verify(vkI,(Request(req)),req_sig) then ( *)
(*FIX*)    if verify(vkI,(vkR,Request(req)),req_sig) then (
         event RecvReq(vkI,vkR,req);
	 let resp = f(req) in
	 event SendResp(vkI,vkR,req,resp);
(*BUG*) (*   let resp_sig = sign(skR,(Response(resp))) in *)
(*FIX*)	 let resp_sig = sign(skR,(vkI,Request(req),Response(resp))) in
	 out (ch,pk_enc(ekI,(Response(resp),resp_sig)))).


(* Test Scenario *)

(* Private Keys for honest A, B, and a compromised principal O *)
free skA:skey [private].
free skB:skey [private].
free dkA:dkey [private].
free dkB:dkey [private].
free skO:skey.
free dkO:dkey.

(* Secret Requests send by A and B *)
free reqAB:bitstring [private].
free reqAB':bitstring [private].
free reqBA:bitstring [private].
free reqAO:bitstring.
free reqOB:bitstring.

(* Main process: any number of sessions between A and B *)

let main =
    !I(skA,dkA,skey2vkey(skB),dkey2ekey(dkB),reqAB) |
    !R(skB,dkB,skey2vkey(skA),dkey2ekey(dkA)) |
    !I(skB,dkB,skey2vkey(skA),dkey2ekey(dkA),reqBA) |
    !R(skA,dkA,skey2vkey(skB),dkey2ekey(dkB)) |
    !I(skA,dkA,skey2vkey(skO),dkey2ekey(dkO),reqAO) |
    !R(skB,dkB,skey2vkey(skO),dkey2ekey(dkO)) |
    !I(skA,dkA,skey2vkey(skB),dkey2ekey(dkB),reqAB') |
    out(ch,(skey2vkey(skA),dkey2ekey(dkA),skey2vkey(skB),dkey2ekey(dkB),skO,dkO)).

(* SECURITY GOALS *)

(* Secrecy Goals: reqAB, f(reqAB), reqBA, f(reqBA) should be secret *)
query attacker(reqAB).
query attacker(f(reqAB)).
query attacker(reqBA).
query attacker(f(reqBA)).

(* Authentication Goals, stated as correspondences between protocol events *)
query req:bitstring;
      event(RecvReq(skey2vkey(skA),skey2vkey(skB),req)) ==>
      event(SendReq(skey2vkey(skA),skey2vkey(skB),req)).
query req:bitstring,resp:bitstring;
      event(RecvResp(skey2vkey(skA),skey2vkey(skB),req,resp)) ==>
      event(SendResp(skey2vkey(skA),skey2vkey(skB),req,resp)).


query event(SendReq(skey2vkey(skA),skey2vkey(skB),reqAB)).
query event(SendReq(skey2vkey(skB),skey2vkey(skA),reqBA)).
query event(SendReq(skey2vkey(skA),skey2vkey(skO),reqAO)).
query event(RecvReq(skey2vkey(skA),skey2vkey(skB),reqAB)).
query event(RecvReq(skey2vkey(skB),skey2vkey(skA),reqBA)).
query event(RecvReq(skey2vkey(skO),skey2vkey(skB),reqOB)).
query event(SendResp(skey2vkey(skA),skey2vkey(skB),reqAB,f(reqAB))).
query event(SendResp(skey2vkey(skB),skey2vkey(skA),reqBA,f(reqBA))).
query event(SendResp(skey2vkey(skO),skey2vkey(skB),reqOB,f(reqOB))).
query event(RecvResp(skey2vkey(skA),skey2vkey(skB),reqAB,f(reqAB))).
query event(RecvResp(skey2vkey(skB),skey2vkey(skA),reqBA,f(reqBA))).
query event(RecvResp(skey2vkey(skA),skey2vkey(skO),reqAO,f(reqAO))).

process main






